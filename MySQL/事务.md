## 事务

### 1. 概述

**什么是事务？**

构成单一逻辑单元的操作集合，我们称为**事务**(transaction)

事务中的操作要么全部都发生，要么全部都不发生

### 2. 事务的基本操作

- `START TRANSACTION / BEGIN`: 开启一个事务，标记事务的起点
- `COMMIT`：提交事务，表示事务成功被执行
- `ROLL BACK`: 回滚事务，回滚到初始状态或者回滚点
- `SAVEPOINT`: 回滚点
- `RELEASE SAVEPOINT`: 删除回滚点
- `SET TRANSACTION`: 设置隔离级别

**注意事项**：

1. `START TRANSACTION`标志事务的开始，在MySQL中可以用`set autocommit = 0` 替代的

2. 结束事务的情况只有两种：

   a. `COMMIT`：表示事务成功被执行(表示所有语句都执行过了，但是不一定成功)，结束事务。

   b. 发生故障：结束事务, 不管有没有设置回滚点，都会回到事务开启前的状态。
   
3. `ROLLBACK`：不表示发生故障, 它也是一个数据库操作，属于事务的一部分。表示回滚事务，回滚到事务开启前的状态，或者中间的某个回滚点。要想 `rollback` 生效，必须要 `commit`

### 3. 性质-ACID

- **原子性（Atomicity）**

  事务是不可分割的工作单位，事务中的操作要么都发生，要么都不发生

- **一致性（Consistency）**

  事务从开始到结束，数据库的状态必须是一致的

- **隔离性（Isolation）**

  每个事务都应该感觉不到系统中有其他事物在并发的执行

- **持久性（Durability）**

  一个事务成功完成之后，他对数据库的改变必须是永久的

在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的

### 4. 并发执行时可能引发的问题

#### 4.1 脏写

指的是，多个事务并发写同一个数据的时候，先执行的事务所写的数据会被后执行的事务写的数据覆盖

导致更新丢失，就好像先提交的事务根本没有执行一样，我们把这种现象称之为**脏写**

#### 4.2 脏读

如果一个事务A向数据库写数据，但该事务还没提交或终止，另一个事务B就看到了事务A写入数据库的数据，这个现象我没法称为**脏读**

#### 4.3 不可重复读

不可重复读是指，一个事务对同一个数据项的多次数取，但是在某前后两次读取之间，另一个事务更新该数据项，并且提交了。在后一次读取时，感知到了提交的更新，这个现象我们称为**不可重复读**。

虽然读取的是已经提交的数据，但是违反了隔离的定义，写数据的事务对读数据的事务，确实产生了影响，没有做到完全隔离

#### 4.4 幻读

一个事务需要进行前后两次统计，在这两次统计期间，另一个事务插入了新的符合统计条件的记录，并且提交了。导致前后两次统计的数据不一致，这种显现，我们称之为**幻读**。

**幻读和不可重复读的区别在于:**

不可重复读，是另一个事务更新了数据项，而幻读是另一个事务插入了新的数据项，一个是更新，一个是增加

#### 4.5 总结

- **脏写**：两个事务并发的对同一项数据进行写操作
- **脏读**：两个事务并发执行，一个事务写数据，另一个事务读数据，但是可以读取未提交的数据
- **不可重复读**：一个事务至少读两次数据，一个事务写数据。在前后两次读取之间，感知到了另一个事务提交的更新
- **幻读**：前后多次读取，统计的数据不一致

既然并发执行事务可能引发这么多问题，那么我们应该怎么应对呢？

数据库提供了不同的隔离级别来应对不同的问题

### 5. 隔离级别

#### 5.1 四种隔离级别

SQL标准规定了四种隔离级别，分别是

- 读未提交（``read uncommitted`)
- 读已提交（``read committed`）
- 可重复读（``repeatable read`）
- 可串行化（``serializable`）

隔离性依次增高：

`read uncommitted` -> `read committed` -> `repeatable read`-> `serializable`

![隔离级别解决的问题](C:\Users\heihei\Desktop\Typora\学习\王道\MySQL\隔离级别解决的问题.PNG)

但是在MySQL中，通过gap lock + next lock，`repeatable read` 大多数情况下已经避免了幻读的出现

#### 5.2 设置MySQL的隔离级别

~~~mysql
select @@[session|global] transaction isolation;
set [session|global] transaction isolation level read uncommitted;
~~~



注意：

- MySQL支持4种隔离级别，默认为RR(`repeatable read`)
- Oracle只支持 `read committed` 和 `serializable` 两种隔离级别， 默认为 `read committed`











